#!/bin/bash
#
# SEQUENTIAL / NON-PARALLEL VERSION
# This script scans all accounts and regions in a linear fashion.
# It is compatible with older, python-based versions of yq by using jq directly.
# It must be run from an authenticated session (e.g., via aws-vault).

set -euo pipefail

# --- Configuration ---
ASSUME_ROLE_NAME="OrganizationAccountAccessRole"
OUTPUT_FILE="$HOME/.config/aws/eks/clusters.yaml"

# --- Main Logic ---
echo "Starting EKS cluster discovery (SEQUENTIAL MODE)..."

# Ensure the target directory exists before we try to write to it.
mkdir -p "$(dirname "$OUTPUT_FILE")"

# --- Cache the initial management credentials ---
echo "Caching initial management credentials..."
MGMT_AWS_ACCESS_KEY_ID="${AWS_ACCESS_KEY_ID:-}"
MGMT_AWS_SECRET_ACCESS_KEY="${AWS_SECRET_ACCESS_KEY:-}"
MGMT_AWS_SESSION_TOKEN="${AWS_SESSION_TOKEN:-}"
MGMT_AWS_REGION="${AWS_REGION:-${AWS_DEFAULT_REGION:-}}"
MGMT_AWS_PROFILE="${AWS_PROFILE:-}"

# Verify that initial credentials were found.
if [ -z "$MGMT_AWS_ACCESS_KEY_ID" ]; then
    echo "Error: Initial AWS credentials (AWS_ACCESS_KEY_ID) not found in the environment." >&2
    echo "Please run this script from an authenticated session (e.g., 'aws-vault exec <profile> -- ./script.sh')." >&2
    exit 1
fi

echo "Fetching all active AWS accounts and regions..."
ACCOUNTS_JSON=$(aws organizations list-accounts --query 'Accounts[?Status==`ACTIVE`].{Id:Id, Name:Name}')
REGIONS=$(aws ec2 describe-regions --query "Regions[].RegionName" --output text)

ALL_CLUSTER_OBJECTS=()
ACCOUNT_IDS=$(echo "$ACCOUNTS_JSON" | yq -r '.[].Id')
TOTAL_ACCOUNTS=$(echo "$ACCOUNT_IDS" | wc -w | xargs)
CURRENT_ACCOUNT=0

# --- Main loop with robust credential reapplying ---
for account_id in $ACCOUNT_IDS; do
    CURRENT_ACCOUNT=$((CURRENT_ACCOUNT + 1))
    account_name=$(echo "$ACCOUNTS_JSON" | yq -r ".[] | select(.Id == \"$account_id\") | .Name")
    echo "--- [${CURRENT_ACCOUNT}/${TOTAL_ACCOUNTS}] Scanning Account: $account_name ($account_id) ---"

    # Reapply the cached management credentials before each assume-role call.
    export AWS_ACCESS_KEY_ID="$MGMT_AWS_ACCESS_KEY_ID"
    export AWS_SECRET_ACCESS_KEY="$MGMT_AWS_SECRET_ACCESS_KEY"
    export AWS_SESSION_TOKEN="$MGMT_AWS_SESSION_TOKEN"
    export AWS_REGION="$MGMT_AWS_REGION"

    if [ -n "$MGMT_AWS_PROFILE" ]; then
        export AWS_PROFILE="$MGMT_AWS_PROFILE"
    else
        unset AWS_PROFILE
    fi

    role_arn="arn:aws:iam::${account_id}:role/${ASSUME_ROLE_NAME}"

    # Use if/else for robust error handling with 'set -e'
    if creds=$(aws sts assume-role --role-arn "$role_arn" --role-session-name "EKS-Discovery-Session-$$" --query "Credentials" 2>&1); then
        # This block runs ONLY on success
        export AWS_ACCESS_KEY_ID=$(echo "$creds" | yq -r .AccessKeyId)
        export AWS_SECRET_ACCESS_KEY=$(echo "$creds" | yq -r .SecretAccessKey)
        export AWS_SESSION_TOKEN=$(echo "$creds" | yq -r .SessionToken)
    else
        # This block runs on ANY failure
        echo "Warning: Could not assume role for account ${account_id}. Skipping. Reason: $(echo $creds | tr -d '\n')" >&2
        continue
    fi

    # Nested loop to iterate through each region for the current account.
    for region in $REGIONS; do
        echo -n "  - Region: $region ... "
        clusters=$(aws eks list-clusters --region "$region" --query "clusters[]" --output text)

        if [ -z "$clusters" ]; then
            echo "No clusters found."
            continue
        fi
        echo "Found: $clusters"

        for cluster_name in $clusters; do
            context_alias="${account_name,,}-${cluster_name}"

            # --- Use jq directly for backwards compatibility ---
            # This creates a compact JSON object without using any modern yq-specific flags.
            cluster_object=$( \
                jq -n -c \
                  --arg name "$cluster_name" \
                  --arg region "$region" \
                  --arg account_id "$account_id" \
                  --arg alias "$context_alias" \
                  '{name: $name, region: $region, account_id: $account_id, alias: $alias}'
            )
            ALL_CLUSTER_OBJECTS+=("$cluster_object")
        done
    done
done

# --- Final Consolidation ---
echo "---"
echo "All scans complete. Consolidating results and writing to '$OUTPUT_FILE'..."

if [ ${#ALL_CLUSTER_OBJECTS[@]} -eq 0 ]; then
    echo "No EKS clusters were found across any account. Writing an empty config file."
    echo "# Auto-generated by discover-eks-clusters.sh. No clusters found." > "$OUTPUT_FILE"
    echo "[]" >> "$OUTPUT_FILE"
else
    # --- FIX: Use a robust jq|yq pipeline for maximum compatibility ---
    # 1. printf sends the stream of individual JSON objects.
    # 2. jq -s (--slurp) reads the stream and wraps it into a single JSON array.
    # 3. The sort_by filter is applied to this array within jq.
    # 4. The final, sorted JSON array is piped to yq for a simple conversion to YAML.
    printf "%s\n" "${ALL_CLUSTER_OBJECTS[@]}" | jq -s 'sort_by(.account_id, .name)' | yq -P . > "$OUTPUT_FILE"

    # Prepend the auto-generated comment header.
    sed -i'.bak' '1s;^;# Auto-generated by discover-eks-clusters.sh. Do not edit manually.\n;' "$OUTPUT_FILE" && rm -f "${OUTPUT_FILE}.bak"
    CLUSTER_COUNT=$(yq 'length' "$OUTPUT_FILE")
    echo "Successfully discovered and wrote $CLUSTER_COUNT clusters to '$OUTPUT_FILE'."
fi

echo "Discovery complete."
